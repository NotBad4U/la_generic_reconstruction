
\appendix


\section{Alethe}
\label{app:alethe}


\subsection{The Syntax}

\begin{figure}[htb]%[H]
    \[
      \begin{array}{r c l}
     \grNT{proof}           &\grRule & \grNT{proof\_command}^{*} \\
     \grNT{proof\_command}  &\grRule & \textAlethe{(assume}\; \grNT{symbol}\; \grNT{proof\_term}\,\textAlethe{)} \\
                            &\grOr   & \textAlethe{(step}\; \grNT{symbol}\; \grNT{clause}
                                            \; \textAlethe{:rule}\; \grNT{symbol} \\
                            &        & \quad \grNT{premises\_annotation}^{?} \\
                            &        & \quad \grNT{context\_annotation}^{?}\;\grNT{attribute}^{*}\,\textAlethe{)} \\
                            & \grOr  & \textAlethe{(anchor :step}\; \grNT{symbol}\;
                                                \\
                            &        & \quad \grNT{args\_annotation}^{?}\;\grNT{attribute}^{*}\,\textAlethe{)} \\
                            & \grOr  & \textAlethe{(define-fun}\; \grNT{function\_def}\,\textAlethe{)} \\
     \grNT{clause}          &\grRule & \textAlethe{(cl}\; \grNT{proof\_term}^{*}\,\textAlethe{)} \\
     \grNT{proof\_term}     &\grRule & \grNT{term}\text{ extended with } \\
                            &        & \textAlethe{(choice (}\, \grNT{sorted\_var}\,\textAlethe{)}\; \grNT{proof\_term}\,\textAlethe{)}  \\
     \grNT{premises\_annotation} &\grRule & \textAlethe{:premises (}\; \grNT{symbol}^{+}\textAlethe{)} \\
     \grNT{args\_annotation}     &\grRule & \textAlethe{:args}\,\textAlethe{(}\,\grNT{step\_arg}^{+}\,\textAlethe{)}  \\
     \grNT{step\_arg}            &\grRule & \grNT{symbol} \grOr
                                              \textAlethe{(}\; \grNT{symbol}\; \grNT{proof\_term}\,\textAlethe{)} \\
     \grNT{context\_annotation}  &\grRule & \textAlethe{:args}\,\textAlethe{(}\,\grNT{context\_assignment}^{+}\,\textAlethe{)}  \\
     \grNT{context\_assignment}  &\grRule & \textAlethe{(}    \,\grNT{sorted\_var}\,\textAlethe{)}  \\
                                 & \grOr  & \textAlethe{(:=}\, \grNT{symbol}\;\grNT{proof\_term}\,\textAlethe{)} \\
      \end{array}
      \]
      \caption{Alethe grammar}
      \label{fig:grammar}
\end{figure}

%  Lambdapi Definitions for Integer and Binary Arithmetic
\section{Lambdapi Formalizations for Integer and Binary Number Operations}
\label{app:lambdapi-func-def}

\noindent
\begin{minipage}[t]{0.48\textwidth}
% \textbf{\ttfamily add : \bb{P} \ra \bb{P} \ra \bb{P}}

\begin{align*}
&\tt{add} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add}~(\tt{I}~x)~(\tt{I}~q) \re \tt{O}~(\tt{add\_c}~x~q) \\
& \tt{add}~(\tt{I}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add}~x~q) \\
& \tt{add}~x~\tt{H} \re \tt{succ}~x \\
& \tt{add}~\tt{H}~y \re \tt{succ}~y \\
\end{align*}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&\tt{add\_c} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add\_c}~(\tt{I}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add\_c}~x~q) \\
& \tt{add\_c}~(\tt{I}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add\_c}~x~q) \\
& \tt{add\_c}~(\tt{O}~x)~(\tt{I}~q) \re \tt{O}~(\tt{add\_c}~x~q) \\
& \tt{add\_c}~(\tt{O}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add\_c}~x~\tt{H} \re \tt{add}~x~(\tt{O}~\tt{H}) \\
& \tt{add\_c}~\tt{H}~y \re \tt{add}~(\tt{O}~\tt{H})~y \\
\end{align*}
\end{minipage}

\begin{align*}
&\tt{sub} : \bb{P} \ra \bb{P} \ra \bb{Z} \\
& \tt{sub}~(\tt{I}~p)~(\tt{I}~q) \re \tt{double}~(\tt{sub}~p~q) \\
& \tt{sub}~(\tt{I}~p)~(\tt{O}~q) \re \tt{succ\_double}~(\tt{sub}~p~q) \\
& \tt{sub}~(\tt{I}~p)~\tt{H} \re \ZPos (\tt{O}~p) \\
& \tt{sub}~(\tt{O}~p)~(\tt{I}~q) \re \tt{pred\_double}~(\tt{sub}~p~q) \\
& \tt{sub}~(\tt{O}~p)~(\tt{O}~q) \re \tt{double}~(\tt{sub}~p~q) \\
& \tt{sub}~(\tt{O}~p)~\tt{H} \re \ZPos (\tt{pos\_pred\_double}~p) \\
& \tt{sub}~\tt{H}~(\tt{I}~q) \re \ZNeg    (\tt{O}~q) \\
& \tt{sub}~\tt{H}~(\tt{O}~q) \re \ZNeg    (\tt{pos\_pred\_double}~q) \\
& \tt{sub}~\tt{H}~\tt{H} \re \tt{Z0} \\
\end{align*}

\begin{align*}
&\tt{compare\_acc} : \bb{P} \ra \tt{Comp} \ra \bb{P} \ra \tt{Comp} \\
& \tt{compare\_acc}~(\tt{I}~x)~c~(\tt{I}~q) \re \tt{compare\_acc}~x~c~q \\
& \tt{compare\_acc}~(\tt{I}~x)~\_~(\tt{O}~q) \re \tt{compare\_acc}~x~\tt{Gt}~q \\
& \tt{compare\_acc}~(\tt{I}~\_)~\_~\tt{H} \re \tt{Gt} \\
& \tt{compare\_acc}~(\tt{O}~x)~\_~(\tt{I}~q) \re \tt{compare\_acc}~x~\tt{Lt}~q \\
& \tt{compare\_acc}~(\tt{O}~x)~c~(\tt{O}~q) \re \tt{compare\_acc}~x~c~q \\
& \tt{compare\_acc}~(\tt{O}~\_)~\_~\tt{H} \re \tt{Gt} \\
& \tt{compare\_acc}~\tt{H}~\_~(\tt{I}~\_) \re \tt{Lt} \\
& \tt{compare\_acc}~\tt{H}~\_~(\tt{O}~\_) \re \tt{Lt} \\
& \tt{compare\_acc}~\tt{H}~c~\tt{H} \re c \\
\\
&\tt{compare}~x~y \coloneq \tt{compare\_acc}~x~\tt{Eq}~y \\
\end{align*}
  
\begin{minipage}[t]{0.45\textwidth}
\begin{align*}
&\tt{mul} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{mul}~(\tt{I}~x)~y \re \tt{add}~y~(\tt{O}~(\tt{mul}~x~y)) \\
& \tt{mul}~(\tt{O}~x)~y \re \tt{O}~(\tt{mul}~x~y) \\
& \tt{mul}~\tt{H}~y \re y \\
& \tt{mul}~y~\tt{H} \re y \\
\end{align*}
\end{minipage}
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \tt{Z0} *~\_ \re \tt{Z0} \\
& \_ *~\tt{Z0} \re \tt{Z0} \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
\end{minipage}

\subsection{Confluence of the rewriting rules of integers and positive binary number}
\label{app:confluence-int-pos}

The rules presented below represent the relations $\ra_\bb{Z}$ and $\ra_\bb{P}$ encoded in the TRS\footnote{\url{http://www.lri.fr/~marche/tpdb/format.html}} format accepted by the \cite{CSI} tool.
These rules can be used to rerun the tool in order to verify the confluence property.

\begin{lstlisting}[language=trs, caption=Rewriting rule of $\bb{Z}$ and $\bb{P}$ in the TRS format]
(VAR
  a: Z
  b: Z
  x : P
  q : P
  y : P
)
(RULES
  ~(Z0) -> Z0
  ~(Zpos(p)) -> Zneg(p)
  ~(Zneg(p)) -> Zpos(p)
  ~(~(a)) -> a

  double(Z0) -> Z0
  double(Zpos(p)) -> Zpos(O(p))
  double(Zneg(p)) -> Zneg(O(p))
  
  succ_double(Z0) -> Zpos(H)
  succ_double(Zpos(p)) -> Zpos(I(p))
  succ_double(Zneg(p)) -> Zneg(pos_pred_double(p))
  
  pred_double(Z0) -> Zneg(H)
  pred_double(Zpos(p)) -> Zpos(pos_pred_double(p))
  pred_double(Zneg(p)) -> Zneg(I(p))

  sub(I(p), I(q)) -> double(sub(p, q))
  sub(I(p), O(q)) -> succ_double(sub(p, q))
  sub(I(p), H) -> Zpos(O(p))
  sub(O(p), I(q)) -> pred_double(sub(p, q))
  sub(O(p), O(q)) -> double(sub(p, q))
  sub(O(p), H) -> Zpos(pos_pred_double(p))
  sub(H, I(q)) -> Zneg(O(q))
  sub(H, O(q)) -> Zneg(pos_pred_double(q))
  sub(H, H) -> Z0

  +(Z0,a) -> a
  +(a,Z0) -> a
  +(Zpos(x), Zpos(y)) -> Zpos(add(x, y))
  +(Zpos(x), Zneg(y)) -> sub(x, y)
  +(Zneg(x), Zpos(y)) -> sub(y, x)
  +(Zneg(x), Zneg(y)) -> Zneg(add(x, y))
  
  mult(Z0, a) -> Z0
  mult(a, Z0) -> Z0
  mult(Zpos(x), Zpos(y)) -> Zpos(mul(x, y))
  mult(Zpos(x), Zneg(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zpos(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zneg(y)) -> Zpos(mul(x, y))


  succ(I(x)) -> O(succ(x))
  succ(O(x)) -> I(x)
  succ(H) -> O(H)
  add(I(x), I(q)) -> O(addcarry(x, q))
  add(I(x), O(q)) -> I(add(x, q))
  add(O(x), I(q)) -> I(add(x, q))
  add(O(x), O(q)) -> O(add(x, q))
  add(x, H) -> succ(x)
  add(H, y) -> succ(y)

  addcarry(I(x), I(q)) -> I(addcarry(x, q))
  addcarry(I(x), O(q)) -> O(addcarry(x, q))
  addcarry(O(x), I(q)) -> O(addcarry(x, q))
  addcarry(O(x), O(q)) -> I(add(x, q))
  addcarry(x, H) -> add(x, O(H))
  addcarry(H, y) -> add(O(H), y)
  
  pos_pred_double(I(x)) -> I(O(x))
  pos_pred_double(O(x)) -> I(pos_pred_double(x))
  pos_pred_double(H) -> H
  
  mul(I(x), y) -> add(x, O(mul(x,y)))
  mul(O(x), y) -> O(mul(x, y))
  mul(H, y) -> y
)
\end{lstlisting}


% Proof:
%  Church Rosser Transformation Processor (no redundant rules):
%   strict:
   
%   weak:
   
% critical peaks: 4
%   add(O(H()),H()) <-6|[]- addcarry(H(),H()) -7|[]-> add(H(),O(H()))
%   add(H(),O(H())) <-7|[]- addcarry(H(),H()) -6|[]-> add(O(H()),H())
%   succ(H()) <-12|[]- add(H(),H()) -13|[]-> succ(H())
%   succ(H()) <-13|[]- add(H(),H()) -12|[]-> succ(H())

%   Church Rosser Transformation Processor (critical pair closing system, Thm 2.4):
%   add(x,H()) -> succ(x)
%   add(H(),y) -> succ(y)
%   critical peaks: joinable
%   Matrix Interpretation Processor: dim=1
    
%     interpretation:
%     [succ](x0) = 4x0,
    
%     [add](x0, x1) = 4x0 + 4x1 + 2,
    
%     [H] = 4
%     orientation:
%     add(x,H()) = 4x + 18 >= 4x = succ(x)
    
%     add(H(),y) = 4y + 18 >= 4y = succ(y)
%     problem:
    
%     Qed
\begin{lemma}[Confluence]
\begin{proof}
CSI automatically proves the confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$ by giving the polynomial interpretation:
\begin{align*}
[\tt{succ}(x)] = 4*x & &[\tt{add}(x, y)] = 4 * x + 4 * y + 2  & &[ {\tt{H}} ] = 4 \\
\end{align*}
\end{proof} 
\end{lemma}