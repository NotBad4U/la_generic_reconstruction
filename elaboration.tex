\section{The approach to reconstruct lia\_generic step}
\label{sec:elaboration-lia}

The \tt{lia\_generic} represent a challenge for reconstruction because the coefficients are not provided by the solver in the trace i.e. \colorbox{orange!30}{$[a_1 \dots a_r]$} is empty.
We decided to leverage the elaboration process of $\tt{lia\_generic}$ performed by Carcara, as doing otherwise would require implementing Fourier-Motzkin elimination for integers, as demonstrated in \cite{omegatest,micromega} -
and therefore reimplementing the work done by the solver.

Carcara considers $\tt{lia\_generic}$ steps as holes in the proof,  as "their checking is as hard as solving" \cite[\S 3.2]{carcara}.
To address this, Carcara leverages an external tool that produces Alethe proofs in order to reformulate each $\tt{lia\_generic}$ step into a corresponding problem. 
The proof is then imported, and validated before replacing the original step. However, at present, Carcara only use cvc5 for performing this task.
In detail, the elaboration method, when encountering a $\tt{lia\_generic}$ step S concluding the negated inequalities $ \neg l_1 \lor \dots \neg l_n$ , generates an SMT-LIB problem asserting $l_1 \land \dots \land l_n$ and invokes \emph{cvc5} on it, expecting an Alethe proof $\pi : (l_1 \land \dots \land l_n) \ra \bot$
that do not use $\tt{lia\_generic}$. Carcara will check this subproof and then replace step $S$ in the original proof by a proof of the form:

\begin{lstlisting}[language=SMT]
(step S (cl (not l1) ... (not ln)) :rule lia_generic)
\end{lstlisting}

\begin{center}
\lightning
\end{center}

\begin{lstlisting}[language=SMT,caption={Elaboration of $\tt{lia\_generic}$},label={lst:elab_lia}]
(anchor :step S.t_m+1)
(assume S.h_1 l1)
...
(assume S.h_n ln)
...
(step t.t_m (cl false) :rule ...)
(step t.t_m+1 (cl (not l1) ... (not ln) false) :rule subproof)
(step t.t_m+2 (cl (not false)) :rule false)
(step S (cl (not l1) ... (not ln)) :rule resolution :premises (S.t_m+1 S.t_m+2))
\end{lstlisting}

% In the next section, we first present an overview of our embedding of Alethe in Lambdapi, and then our automatic procedure to reconstruct $\tt{la\_generic}$ step that appear in LIA problem.
