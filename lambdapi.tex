\section{Reconstruction of \tt{la\_generic} step for LIA logic}
\label{sect:recon-lambdapi}

\subsection{An Overview of Lambdapi}
\label{ssect:lambdapi-overview}

Lambdapi is an implementation of $\lambda\Pi$ modulo theory ($\lpm$) \cite{lambdapi}, an extension of the Edinburgh Logical Framework $\lambda\Pi$ \cite{lf}, a simply typed $\lambda$-calculus with dependent types. $\lpm$ adds user-defined higher-order rewrite rules. Its syntax is given by
%
\begin{align*}
&\text{Universes}  &u &::= \type ~|~ \kind \\
&\text{Terms}   &t,v, A,B,C &::= c ~|~ x ~|~ u ~|~ \Pi\,x : A,\,B~|~ \lambda\,x : A,\,t ~|~t~v \\
&\text{Contexts}   &\Gamma &::= \langle \rangle ~|~ \Gamma, x : A \\
&\text{Signatures}  &\Sigma &::= \langle \rangle ~|~ \Sigma, c : C ~|~ \Sigma, c := t : C ~|~ \Sigma, t \hookrightarrow v 
\end{align*}
%
where $c$ is a constant and $x$ is a variable  (ranging over disjoint sets), $C$ is a closed term. \emph{Universes} are constants used to verify if a type is well-formed -- more details can be found in \cite[\S 2.1]{lf}. $\Pi\,x : A.\,B$ is the dependent product, and we write $A \rightarrow B$ when $x$ does not appear free in $B$, $\lambda\,x : A.\,t$ is an abstraction, and  $t~v$ is an application. A \emph{(local) context} $\Gamma$ is a finite sequence of variable declarations $x:A$ introducing variables and their types.
A \emph{signature} $\Sigma$ representing the global context is a finite sequence of \emph{assumptions} $c : C$, indicating that constant $c$ is of type $C$, \emph{definitions} $c := t : C$, indicating that $c$ has the value $t$ and type $C$, and \emph{rewrite rules} $t \hookrightarrow v$ such that $t = c~v_1 \dots v_n$ where $c$ is a constant.

The relation $\hookrightarrow_{\beta\Sigma}$ is generated by $\beta$-reduction and by the rewrite rules of $\Sigma$. The relation $\hookrightarrow_{\beta\Sigma}^*$ denotes the reflexive and transitive closure of $\hookrightarrow_{\beta\Sigma}$, and the relation $\equiv_{\beta\Sigma}$ (called \emph{conversion}) the reflexive, symmetric, and transitive closure of $\hookrightarrow_{\beta\Sigma}$. 
The relation $\hookrightarrow_{\beta\Sigma}$ must be confluent, i.e.,
whenever $t \hookrightarrow_{\beta\Sigma}^* v_1$ and $t \hookrightarrow_{\beta\Sigma}^* v_2$, there exists a term $w$ such that $v_1 \hookrightarrow_{\beta\Sigma}^* w$ and $v_2 \hookrightarrow_{\beta\Sigma}^* w$, and it must preserve typing, i.e., 
whenever $\Gamma \vdash_\Sigma t: A$ and $t \hookrightarrow_{\beta\Sigma} v$ then $\Gamma \vdash_\Sigma v: A$ \cite{blanqui:LIPIcs.FSCD.2020.13}.

A Lambdapi typing judgment $\Gamma \vdash_\Sigma t : A$ asserts that term $t$ has type $A$ in the context $\Gamma$ and the signature $\Sigma$.
The typing rules of $\lpm$ are the one of  $\lambda\Pi$ \cite[\S 2]{lf}, except for the rule (Conv) where it use the version of \cref{fig:lp-typing-rules} that identifies types modulo~$\textcolor{orange}{\equiv_{\beta\Sigma}}$ instead of just modulo $\beta$-reduction. 

\begin{figure}
    \begin{center}
    \begin{prooftree}
    \hypo{\Gamma, \vdash_\Sigma B: u}
    \hypo{\Gamma \vdash_\Sigma t: A}
    \hypo{\textcolor{orange}{A \equiv_{\beta\Sigma} B}}
    \infer3[(Conv)]{ \Gamma \vdash_\Sigma t: B }
    \end{prooftree}
    \end{center}
    \caption{(Conv) rule in $\lpm$}
    \label{fig:lp-typing-rules}
  \end{figure}

We now provide an overview of the encoding of Alethe linear integers arithmetic in Lambdapi.

\subsection{Encoding of Integers in Lambdapi}


\begin{figure}
\centering
\begin{align*}\label{eq:eq1}
&\bb{Z}: \type & &\bb{P}: \type  & &\tt{Comp}: \type & &\bb{B}: \type \\
&|~\tt{Z0}: \bb{Z} & &|~\tt{H} : \bb{P} & &|~\tt{Eq}: \tt{Comp} & &|~\tt{true}: \bb{B} \\
&|~\tt{ZPos}: \bb{P} \ra \bb{Z} & &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\tt{Lt}: \tt{Comp} & &|~\tt{false}: \bb{B} \\
&|~\tt{ZNeg}: \bb{P} \ra \bb{Z} & &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\tt{Gt}: \tt{Comp} & &\\
&\tt{int}: \set & &\tt{pos}: \set & &\tt{comp}: \set & &\tt{bool}: \set \\
&\el~\tt{int} \re \bb{Z} & &\el~\tt{pos} \re \bb{P} & &\el~\tt{comp} \re \tt{Comp} & &\el~\tt{comp} \re \bb{B}
\end{align*}
\caption{Overview of sorts, constructors, constants, and element relations}
\label{fig:sorts-constructors}
\end{figure}

The definition we use of integers in Lambdapi in \cref{fig:sorts-constructors} follows a common encoding found in many other theories, including the one adopted in the Rocq standard library \cite{Rocq-refman}.
First, the type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or constructor \tt{I} (digit 1). 
The type $\bb{Z}$ is an inductive type representing integers in binary form.
An integer is either zero (with constructor \tt{Z0}) or a strictly positive number \tt{Zpos} (coded as a $\bb{P}$) or a strictly negative number \tt{Zneg} (whose opposite is stored as a $\bb{P}$ value).
%
As discussed in our previous work \cite{ColtellacciMD24}, $\lpm$ does not support quantiﬁy over a variable of type $\type$. More precisely, it is not possible to assign the type $\Pi X : \type,(X \ra \prop) \ra \prop$ to the universal quantifier $\forall$, where $\prop: \type$ is the type of proposition.
To address this, we introduce a constant $\set : \type$ for the types of object-terms, and a constant ${\el}$ to embed the terms of type $\set$ into terms of type $\type$ giving us the quantifier $\forall: \Pi x: \set, (\el~x \ra \prop) \ra \prop$.
%
To enable quantification over types such as integers, positive binary numbers, booleans, and comparison results, we introduce a constant of type $\set$ (e.g. $\tt{int}: \set$) that represents codes for these types — similar to the Tarski-style universe \cite[\S Universes]{intuitype},
where types are represented by elements of a base type and interpreted via the decoding function. In our setting, the decoding function $\el$  is realized through a rewriting rule that reduces the term to its corresponding type; for example, $\el~\tt{int} \re \bb{Z}$.
The comparison datatype $\tt{Comp}$ is utilized to define the decidable equality $\doteq$ between the $\bb{Z}$ and the function \tt{cmp} for $\bb{P}$ (as defined in \cref{app:lambdapi-func-def}).

\begin{figure}
\centering
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \tt{Z0} + y \re y \\
& x + \tt{Z0} \re \tt{Z0} \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\tt{Zpos}~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \tt{Zpos}(\tt{add}~x~y)  \\
\end{align*}
\hfill
\end{minipage}
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&\doteq : \bb{Z} \ra \bb{Z} \ra \tt{Comp} \\
& \tt{Z0} \doteq \tt{Z0} \re \tt{Eq} \\
& \tt{Z0} \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Z0} \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zpos}~\_ \doteq \tt{Z0} \re \tt{Gt} \\
& \tt{Zpos}~p \doteq \tt{Zpos}~q \re \tt{cmp}~p~q \\
& \tt{Zpos}~\_ \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zneg}~\_ \doteq \tt{Z0} \re \tt{Lt} \\
& \tt{Zneg}~\_ \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Zneg}~p \doteq \tt{Zneg}~q \re \tt{cmp}~q~p \\
\end{align*}
\end{minipage}
\noindent
\[
\begin{array}{l@{\hspace{4em}}l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \bb{B} \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true} \\
\end{aligned}
\end{array}
\]
\noindent
\begin{align*}
&\leq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) & &\tt{istrue} : \bb{B} \ra \prop \\
&<: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) & &\tt{istrue}~\tt{true} \re \top \\
&\geq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x < y) & &\tt{istrue}~\tt{false} \re \bot \\
&>: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y) & & \\
\end{align*}

\caption{Decidable equality, $+$ operator and inequalities relations definitions for $\bb{Z}$}
\label{fig:arith-ops}
\end{figure}

The arithmetic operator such as \tt{add}, \tt{sub}, and others, as presented in \cref{fig:arith-ops} are constants defined by rewriting rules. In the following sections, we will refers 
to the rewriting rules for integers as $\ra_\bb{Z}$ and positive binary numbers as $\ra_\bb{P}$.
The confluence of the rewriting rules for the arithmetic of $\mathbb{Z}$ and $\mathbb{P}$ has been proven using CSI \cite{CSI}. A detailed proof of confluence can be found in \cref{app:confluence-int-pos}.
The inequality symbols for $\bb{Z}$ are binary predicates defined by rewriting rules over the decidable equality $\doteq$. They reduce to $\top$, $\bot$ (or negated) by $\equivL$ with rules of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
For example, $1 < 2 \hookrightarrow \tt{istrue}(\tt{isLt}(1 \doteq 2)) \hookrightarrow \tt{istrue}(\tt{isLt}(\tt{Lt})) \hookrightarrow \tt{istrue}(\tt{true}) \hookrightarrow \top$.

\subsection{Functions used in the translation}

We now provide an overview of how input problems expressed in a given SMT-LIB signature \cite[\S 5.2.1]{smtlib} are encoded.
A comprehensive description of the encoding can be found in \cite{ColtellacciMD24}, we will focus here on the arithmetic.
In order to avoid a notational clash with the Lambdapi signature $\Sigma$, we denote the set of SMT-LIB sorts as $\Theta^\mathcal{S}$, the set of function symbols $\Theta^\cal{F}$, and the set of variables $\Theta^\cal{X}$.
Our translation is based on the following functions:

\begin{itemize}
\item $\cal{D}$ translates declarations of sorts and functions in $\Theta^\cal{S}$ and $\Theta^\mathcal{F}$ into constants,
\item $\cal{S}$ maps sorts to $\Sigma$ types,
\item $\cal{E}$ translates SMT expression to $\lpm$ terms,
\item $\cal{C}$ translates a list of commands  $c_1 \dots c_n$ of the form $i.~\Gamma \triangleright~\varphi~(\mathcal{R}~P)[A]$ to typing judgments $\Gamma \vdash_\Sigma i := M: N$.
\end{itemize}

\begin{definition}[Function $\mathcal{D}$ translating SMT sort and function symbol declarations]
For each sort symbol $s$ with arity $n$ in $\Theta^\cal{S}$ we create a constant $s: \set \ra \dots \ra \set$.
For each function symbol $f~\sigma^+$ in $\Theta^\cal{F}$ we create a constant $f: \cal{S}(\sigma^+)$.
\end{definition}

\begin{definition}[Function $\mathcal{S}$ translating sorts of expression] 
  The definition of $\mathcal{S}$(s) is as follows.
  \begin{itemize}
    \item Case $s = \textbf{Bool}$, then $\Sort{s} = \el\,o$,
    \item Case $s = \textbf{Int}$, then $\Sort{s} = \el~\texttt{int}$,
    \item Case $s = \sigma_1\,\sigma_2 \dots \sigma_n$ then $\Sort{s} = \el{} (\mathcal{S}(\sigma_1) \leadsto \dots \leadsto \mathcal{S}(\sigma_n))$,
    \item otherwise $\Sort{s} = \el\, \mathcal{D}(s)$.
  \end{itemize}
  with the constant $o: \set$ and $\el\, o \re \prop$ to quantify over propositions.
\end{definition}

\begin{definition}[Function $\mathcal{E}$ translating SMT expressions]
The definition of $\E{e}$ is as follows.
\begin{itemize}
\setlength{\parskip}{0pt}
\item Case e $= (p~t_1~t_2\dots~t_n)$ and $p$ a logical connector,\\
  then $\E{e} = \E{t_1}~p^c~\dots~p^c~\E{t_n}$.
\item Case e $= (+~t_1\dots~t_n)$, then $\E{e} = \E{t_1} + ~\dots~ +\E{t_n}$.
\item Case e $= (*~t_1\dots~t_n)$, then $\E{e} = \E{t_1} * ~\dots~ *\E{t_n}$.
\item Case e $= (-t)$, then $\E{e} = \sim \E{t_1}$.
\item Case e $= (-~t_1\dots~t_n)$, then $\E{e} = \E{t_1} - ~\dots~ - \E{t_n}$.
\item Case e $= (\approx~t_1~t_2)$ then $\E{e} = (\E{t_1} = \E{t_2})$.
\item Case e $= (Q~x_1 : \sigma_1  \dots x_n : \sigma_n ~t)$ where $Q\in \{\kw{forall}, \kw{exists}\}$, then $\E{e} = Q^c x_1: \cal{S}(\sigma_1), \dots, Q^c x_n: \cal{S}(\sigma_n), \E{t}$. 
\item Case $e = (x: \sigma )$ with $x \in \Theta^\mathcal{X}$ a sorted variable, then $\E{e} = x: \cal{S}(\sigma)$.
\end{itemize}
\end{definition}

\begin{definition}
We define the function $\cal{C}$ that translates an Alethe step of the form $i.~\Gamma~\triangleright~l_1 \dots l_n\,(R\,P)[A]$ into a constant
$i: \pid (\E{l_1}\cons\dots\cons\E{l_n}\cons \nil) \coloneq M$ where $M$ is a proof term of appropriate type.
The function $\cal{C}$ is defined by cases on the rule $R$.
\end{definition}

We introduce an embedding $\pid: \tt{Clause} \ra \type$ of clause into types, mapping each clause $C$ to the type $\pid~C$ of its proofs.
Similarly, the constant $\pic: \prop \ra \type$ maps each proposition A. The type $\tt{Clause}: \type$ represent the type of clause encoded as list \cite[\S 3]{ColtellacciMD24}
with the constructor $\veedot: \prop \ra \tt{Clause} \ra \tt{Clause}$ and the empty clause $\nil: \tt{clause}$.


\begin{example}{Translation of the proof goal of the prelude, step t2 and t5 in \cref{lst:smtexampleproof}}
\begin{lstlisting}[language=Lambdapi,mathescape=true]
symbol x: El int;
symbol y: El int;
...
opaque symbol t2: $\pid$ (¬ (3 < x)  ⟇ ¬ (x = 2) ⟇ ▩) ≔ begin ... end;
opaque symbol t5: $\pid$ (¬ (x + y < 1) ⟇ (¬ (x = 2))  ⟇ (¬ (0 = y)) ⟇ ▩) ≔ begin ... end;
...
\end{lstlisting}
\end{example}

The proof terms generated by $\mathcal{C}$ for steps \texttt{t2} and \texttt{t5} must faithfully represent the algorithm presented in \cref{ssect:la-in-alethe}.
While steps 1 through 7 of the algorithm correspond to explicit rewriting steps, the final step (step 8) — which involves summing all inequalities represents a multi-step rewriting sequence.
This sequence reduced the initial sum to a decidable comparison between constants (e.g. $0 > 1 \re \bot$), which serves as the conclusion of the reduction.
%
The reflection technique introduced by \cite{reflection-origin-coq} leverages the reduction system of the proof assistant to produce an efficient decidable automatic
procedure for comparing \emph{Ring} terms. We decided to follow this approach to implement our decision procedure for evaluating inequality.
In the following section, we describe how we implemented this procedure for our case, and how we extended the definition of $\mathcal{C}$.