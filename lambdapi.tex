\section{Reconstruction of \tt{la\_generic} step for LIA logic}
\label{sect:recon-lambdapi}

\subsection{Encoding of Integers in Lambdapi}


\begin{figure}
\centering
% \begin{align*}\label{eq:eq1}
% &\bb{Z}: \type & &\bb{P}: \type  & &\tt{Comp}: \type & &\bb{B}: \type \\
% &|~\tt{Z0}: \bb{Z} & &|~\tt{H} : \bb{P} & &|~\tt{Eq}: \tt{Comp} & &|~\tt{true}: \bb{B} \\
% &|~\tt{ZPos}: \bb{P} \ra \bb{Z} & &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\tt{Lt}: \tt{Comp} & &|~\tt{false}: \bb{B} \\
% &|~\tt{ZNeg}: \bb{P} \ra \bb{Z} & &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\tt{Gt}: \tt{Comp} & &\\
% &\tt{int}: \set & &\tt{pos}: \set & &\tt{comp}: \set & &\tt{bool}: \set \\
% &\el~\tt{int} \re \bb{Z} & &\el~\tt{pos} \re \bb{P} & &\el~\tt{comp} \re \tt{Comp} & &\el~\tt{bool} \re \bb{B}
% \end{align*}
\begin{align*}\label{eq:eq1}
  &\bb{P}: \type & &\bb{Z}: \type   & &\tt{Comp}: \type & &\bb{B}: \type \\
  &|~\tt{H} : \bb{P} & &|~\tt{Z0}: \bb{Z} & &|~\tt{Eq}: \tt{Comp} & &|~\tt{true}: \bb{B} \\
  &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\tt{ZPos}: \bb{P} \ra \bb{Z} & &|~\tt{Lt}: \tt{Comp} & &|~\tt{false}: \bb{B} \\
  &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\tt{ZNeg}: \bb{P} \ra \bb{Z} & &|~\tt{Gt}: \tt{Comp} & &\\
  &\tt{pos}: \set & &\tt{int}: \set & &\tt{comp}: \set & &\tt{bool}: \set \\
  &\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \bb{Z} & &\el~\tt{comp} \re \tt{Comp} & &\el~\tt{bool} \re \bb{B}
  \end{align*}
\caption{Overview of sorts, constructors, constants, and element relations}
\label{fig:sorts-constructors}
\end{figure}

The definition we use of integers in Lambdapi in \cref{fig:sorts-constructors} follows a common encoding found in many other theories, including the one adopted in the Rocq standard library \cite{Rocq-refman}.
First, the type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or constructor \tt{I} (digit 1). 
The type $\bb{Z}$ is an inductive type representing integers in binary form.
An integer is either zero (with constructor \tt{Z0}) or a strictly positive number \tt{Zpos} (coded as a $\bb{P}$) or a strictly negative number \tt{Zneg} (whose opposite is stored as a $\bb{P}$ value).
%
To enable quantification over types such as integers, positive binary numbers, booleans, and comparison results, we introduce a constant of type $\set$ (e.g. $\tt{int}: \set$) that represents codes for these types.
In our setting, the decoding function $\el$  is realized through a rewriting rule that reduces the term to its corresponding type; for example, $\el~\tt{int} \re \bb{Z}$.
The comparison datatype $\tt{Comp}$ is utilized to define the decidable equality $\doteq$ between the $\bb{Z}$ and the function \tt{cmp} for $\bb{P}$ (as defined in \cref{app:lambdapi-func-def}).

\begin{figure}
\centering
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \tt{Z0} + y \re y \\
& x + \tt{Z0} \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\tt{Zpos}~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \tt{Zpos}(\tt{add}~x~y)  \\
\end{align*}
\hfill
\end{minipage}
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&\doteq : \bb{Z} \ra \bb{Z} \ra \tt{Comp} \\
& \tt{Z0} \doteq \tt{Z0} \re \tt{Eq} \\
& \tt{Z0} \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Z0} \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zpos}~\_ \doteq \tt{Z0} \re \tt{Gt} \\
& \tt{Zpos}~p \doteq \tt{Zpos}~q \re \tt{cmp}~p~q \\
& \tt{Zpos}~\_ \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zneg}~\_ \doteq \tt{Z0} \re \tt{Lt} \\
& \tt{Zneg}~\_ \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Zneg}~p \doteq \tt{Zneg}~q \re \tt{cmp}~q~p \\
\end{align*}
\end{minipage}
\noindent
\[
\begin{array}{l@{\hspace{4em}}l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \bb{B} \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true} \\
\end{aligned}
\end{array}
\]
\noindent
\begin{align*}
&\leq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) & &\tt{istrue} : \bb{B} \ra \prop \\
&<: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) & &\tt{istrue}~\tt{true} \re \top \\
&\geq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x < y) & &\tt{istrue}~\tt{false} \re \bot \\
&>: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y) & & \\
\end{align*}

\caption{Decidable equality, $+$ operator and inequalities relations definitions for $\bb{Z}$}
\label{fig:arith-ops}
\end{figure}

The arithmetic operator such as \tt{add}, \tt{sub}, and others, as presented in \cref{fig:arith-ops} are constants defined by rewriting rules. In the following sections, we will refers 
to the rewriting rules for integers as $\ra_\bb{Z}$ and positive binary numbers as $\ra_\bb{P}$.
The confluence of the rewriting rules for the arithmetic of $\mathbb{Z}$ and $\mathbb{P}$ has been proven using CSI \cite{CSI}. A detailed proof of confluence can be found in \cref{app:confluence-int-pos}.
The inequality symbols for $\bb{Z}$ are binary predicates defined by rewriting rules over the decidable equality $\doteq$. They reduce to $\top$, $\bot$ (or negated) by $\equivL$ with rules of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
For example, $1 < 2 \hookrightarrow \tt{istrue}(\tt{isLt}(1 \doteq 2)) \hookrightarrow \tt{istrue}(\tt{isLt}(\tt{Lt})) \hookrightarrow \tt{istrue}(\tt{true}) \hookrightarrow \top$.

\subsection{Functions used in the translation}

We now provide an overview of how input problems expressed in a given SMT-LIB signature \cite[\S 5.2.1]{smtlib} are encoded.
A comprehensive description of the encoding can be found in \cite{ColtellacciMD24}, we will focus here on the arithmetic.
In order to avoid a notational clash with the Lambdapi signature $\Sigma$, we denote the set of SMT-LIB sorts as $\Theta^\mathcal{S}$, the set of function symbols $\Theta^\cal{F}$, and the set of variables $\Theta^\cal{X}$.
Our translation is based on the following functions:

\begin{itemize}
\item $\cal{D}$ translates declarations of sorts and functions in $\Theta^\cal{S}$ and $\Theta^\mathcal{F}$ into constants,
\item $\cal{S}$ maps sorts to $\Sigma$ types,
\item $\cal{E}$ translates SMT expression to $\lpm$ terms,
\item $\cal{C}$ translates a list of commands  $c_1 \dots c_n$ of the form $i.~\Gamma \triangleright~\varphi~(\mathcal{R}~P)[A]$ to typing judgments $\Gamma \vdash_\Sigma i := M: N$.
\end{itemize}

\begin{definition}[Function $\mathcal{D}$ translating SMT sort and function symbol declarations]
For each sort symbol $s$ with arity $n$ in $\Theta^\cal{S}$ we create a constant $s: \set \ra \dots \ra \set$.
For each function symbol $f~\sigma^+$ in $\Theta^\cal{F}$ we create a constant $f: \cal{S}(\sigma^+)$.
\end{definition}

\begin{definition}[Function $\mathcal{S}$ translating sorts of expression] 
  The definition of $\mathcal{S}$(s) is as follows.
  \begin{itemize}
    \item Case $s = \textbf{Bool}$, then $\Sort{s} = \el\,o$,
    \item Case $s = \textbf{Int}$, then $\Sort{s} = \el~\texttt{int}$,
    \item Case $s = \sigma_1\,\sigma_2 \dots \sigma_n$ then $\Sort{s} = \el{} (\mathcal{S}(\sigma_1) \leadsto \dots \leadsto \mathcal{S}(\sigma_n))$,
    \item otherwise $\Sort{s} = \el\, \mathcal{D}(s)$.
  \end{itemize}
\end{definition}

\begin{definition}[Function $\mathcal{E}$ translating SMT expressions]
The definition of $\E{e}$ is as follows.
\begin{itemize}
\setlength{\parskip}{0pt}
\item Case e $= (p~t_1~t_2\dots~t_n)$ and $p$ a logical connector,\\
  then $\E{e} = \E{t_1}~p^c~\dots~p^c~\E{t_n}$.
\item Case e $= (+~t_1\dots~t_n)$, then $\E{e} = \E{t_1} + ~\dots~ +\E{t_n}$.
\item Case e $= (*~t_1\dots~t_n)$, then $\E{e} = \E{t_1} * ~\dots~ *\E{t_n}$.
\item Case e $= (-t)$, then $\E{e} = \sim \E{t_1}$.
\item Case e $= (-~t_1\dots~t_n)$, then $\E{e} = \E{t_1} - ~\dots~ - \E{t_n}$.
\item Case e $= (\approx~t_1~t_2)$ then $\E{e} = (\E{t_1} = \E{t_2})$.
\item Case e $= (Q~x_1 : \sigma_1  \dots x_n : \sigma_n ~t)$ where $Q\in \{\kw{forall}, \kw{exists}\}$, then $\E{e} = Q^c x_1: \cal{S}(\sigma_1), \dots, Q^c x_n: \cal{S}(\sigma_n), \E{t}$. 
\item Case $e = (x: \sigma )$ with $x \in \Theta^\mathcal{X}$ a sorted variable, then $\E{e} = x: \cal{S}(\sigma)$.
\end{itemize}
\end{definition}

\begin{definition}
We define the function $\cal{C}$ that translates an Alethe step of the form $i.~\Gamma~\triangleright~l_1 \dots l_n\,(R\,P)[A]$ into a constant
$i: \pid (\E{l_1}\cons\dots\cons\E{l_n}\cons \nil) \coloneq M$ where $M$ is a proof term of appropriate type.
The function $\cal{C}$ is defined by cases on the rule $R$.
\end{definition}

We introduce an embedding $\pid: \tt{Clause} \ra \type$ of clause into types, mapping each clause $C$ to the type $\pid~C$ of its proofs.
The type $\tt{Clause}: \type$ represent the type of clause encoded as list \cite[\S 3]{ColtellacciMD24}
with the constructor $\veedot: \prop \ra \tt{Clause} \ra \tt{Clause}$ and the empty clause $\nil: \tt{clause}$.


\begin{example}{Translation of the proof goal of the prelude, step t2 and t5 in \cref{lst:smtexampleproof}}
\begin{lstlisting}[language=Lambdapi,mathescape=true]
symbol x: El int;
symbol y: El int;
...
opaque symbol t2: $\pid$ (¬ (3 < x)  ⟇ ¬ (x = 2) ⟇ ▩) ≔ begin ... end;
opaque symbol t5: $\pid$ (¬ (x + y < 1) ⟇ (¬ (x = 2))  ⟇ (¬ (0 = y)) ⟇ ▩) ≔ begin ... end;
...
\end{lstlisting}
\end{example}

The proof terms generated by $\mathcal{C}$ for steps \texttt{t2} and \texttt{t5} must faithfully represent the algorithm presented in \cref{ssect:la-in-alethe}.
While steps 1 through 7 of the algorithm correspond to explicit rewriting steps, the final step (step 8) — which involves summing all inequalities represents a multi-step rewriting sequence.
This sequence reduced the initial sum to a decidable comparison between constants (e.g. $0 > 1 \re \bot$), which serves as the conclusion of the reduction.
%
The reflection technique introduced by \cite{reflection-origin-coq} leverages the reduction system of the proof assistant to produce an efficient decidable automatic
procedure for comparing \emph{Ring} terms. We decided to follow this approach to implement our decision procedure for evaluating inequality.
In the following section, we describe how we implemented this procedure for our case, and how we extended the definition of $\mathcal{C}$.