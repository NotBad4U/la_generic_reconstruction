\section{Reconstruction of \tt{la\_generic} step}
\label{sect:recon-lambdapi}

\subsection{Lambdapi}
\label{ssect:lambdapi}

Lambdapi is an implementation of $\lambda\Pi$ modulo theory ($\lpm$) \cite{lambdapi}, an extension of the Edinburgh Logical Framework $\lambda\Pi$ \cite{lf}, a simply typed $\lambda$-calculus with dependent types. $\lpm$ adds user-defined higher-order rewrite rules. Its syntax is given by
%
\begin{align*}
&\text{Universes}  &u &::= \type ~|~ \kind \\
&\text{Terms}   &t,v, A,B,C &::= c ~|~ x ~|~ u ~|~ \Pi\,x : A,\,B~|~ \lambda\,x : A,\,t ~|~t~v \\
&\text{Contexts}   &\Gamma &::= \langle \rangle ~|~ \Gamma, x : A \\
&\text{Signatures}  &\Sigma &::= \langle \rangle ~|~ \Sigma, c : C ~|~ \Sigma, c := t : C ~|~ \Sigma, t \hookrightarrow v 
\end{align*}
%
where $c$ is a constant and $x$ is a variable  (ranging over disjoint sets), $C$ is a closed term. \emph{Universes} are constants used to verify if a type is well-formed -- more details can be found in \cite[\S 2.1]{lf}. $\Pi\,x : A.\,B$ is the dependent product, and we write $A \rightarrow B$ when $x$ does not appear free in $B$, $\lambda\,x : A.\,t$ is an abstraction, and  $t~v$ is an application. A \emph{(local) context} $\Gamma$ is a finite sequence of variable declarations $x:A$ introducing variables and their types.
A \emph{signature} $\Sigma$ representing the global context is a finite sequence of \emph{assumptions} $c : C$, indicating that constant $c$ is of type $C$, \emph{definitions} $c := t : C$, indicating that $c$ has the value $t$ and type $C$, and \emph{rewrite rules} $t \hookrightarrow v$ such that $t = c~v_1 \dots v_n$ where $c$ is a constant.

The relation $\hookrightarrow_{\beta\Sigma}$ is generated by $\beta$-reduction and by the rewrite rules of $\Sigma$. The relation $\hookrightarrow_{\beta\Sigma}^*$ denotes the reflexive and transitive closure of $\hookrightarrow_{\beta\Sigma}$, and the relation $\equiv_{\beta\Sigma}$ (called \emph{conversion}) the reflexive, symmetric, and transitive closure of $\hookrightarrow_{\beta\Sigma}$. 
The relation $\hookrightarrow_{\beta\Sigma}$ must be confluent, i.e.,
whenever $t \hookrightarrow_{\beta\Sigma}^* v_1$ and $t \hookrightarrow_{\beta\Sigma}^* v_2$, there exists a term $w$ such that $v_1 \hookrightarrow_{\beta\Sigma}^* w$ and $v_2 \hookrightarrow_{\beta\Sigma}^* w$, and it must preserve typing, i.e., 
whenever $\Gamma \vdash_\Sigma t: A$ and $t \hookrightarrow_{\beta\Sigma} v$ then $\Gamma \vdash_\Sigma v: A$ \cite{blanqui:LIPIcs.FSCD.2020.13}.

A Lambdapi typing judgment $\Gamma \vdash_\Sigma t : A$ asserts that term $t$ has type $A$ in the context $\Gamma$ and the signature $\Sigma$.
The typing rules of $\lpm$ are the one of  $\lambda\Pi$ \cite[\S 2]{lf}, except for the rule (Conv) where it use the version of \cref{fig:lp-typing-rules} that identifies types modulo~$\textcolor{orange}{\equiv_{\beta\Sigma}}$ instead of just modulo $\beta$-reduction. 

\begin{figure}
    \begin{center}
    \begin{prooftree}
    \hypo{\Gamma, \vdash_\Sigma B: u}
    \hypo{\Gamma \vdash_\Sigma t: A}
    \hypo{\textcolor{orange}{A \equiv_{\beta\Sigma} B}}
    \infer3[(Conv)]{ \Gamma \vdash_\Sigma t: B }
    \end{prooftree}
    \end{center}
    \caption{(Conv) rule in $\lpm$}
    \label{fig:lp-typing-rules}
  \end{figure}

  We now provide an overview of our encoding of Alethe in Lambdapi. A more comprehensive version of the encoding is available in \cite{ColtellacciMD24}.

\subsection{A Prelude Encoding for Alethe}
\label{sect:embedding}

\begin{definition}[Prelude Encoding]
\label{def:defuniv}
The signature $\Sigma$ of our encoding contains the following definitions and rewrite rules provided by the standard library of Lambdapi that we use to encode Alethe proofs:
\begin{align*}
&\set: \type & &\prop: \type \\
&\el: \set \rightarrow \type  & &\prf : \prop \rightarrow \type \\
&\mathop{\leadsto}: \set \rightarrow \set \rightarrow \set & &o: \set \\
&\el\,(x \leadsto y) \hookrightarrow \el\,x \rightarrow \el\,y & &\el\,o  \hookrightarrow \prop \\
\end{align*}
\end{definition}

 The constants \set{} and \prop{} (lines 1 and 6) are type universes ``Ã  la Tarski'' \cite[\S Universes]{intuitype} in $\lpm$.
 The type \set{} represents the universe of \textit{small types}, i.e.\ a subclass of types for which we can define equality.
 SMT sorts are represented in $\lpm$ as elements of type \set{}. Since elements of type \set{} are not types themselves, we also introduce a decoding function $\el: \set \rightarrow \type$ that interprets SMT sorts as $\lpm$ types.
 Thus, we represent the terms of sort \texttt{Bool} of SMT by elements of type $\el{}\,o$. The constructor $\leadsto$ is used to encode SMT functions and predicates.
The type \prop{} represents the universe of propositions in $\lpm$. Like \set{}, elements of type \prop{} are not types themselves but are mapped to types by the decoding function $\prf{}: \prop \rightarrow \type$. By analogy with the Curry-de-Brujin-Howard isomorphism, it embeds propositions into types, mapping each proposition $A$ to the type $\prf{}~A$ of its proofs.

\begin{figure}
\begin{align*}
&\tt{Clause}: \type & &\cal{F}: \tt{Clause} \ra \prop \\
&\nil: \tt{Clause} & & \cal{F}~\nil \re \bot \\
&\veedot: \prop \ra \tt{Clause}  \ra \tt{Clause} & & \cal{F}~x \veedot y \re x \lor^c (\cal{F}~y) \\
&\pid (c : \tt{Clause}) \coloneqq \pic (\cal{F}~c) & &  \\
\end{align*}
\caption{The \tt{Clause} type and operations on clauses.}
\end{figure}

Alethe distinguishes between clauses that appear in steps, \colorbox{green!30}{(cl\,$l_1 \dots l_n$)} in \cref{eq:step}, and ordinary disjunction \cite[\S 4]{alethespec}.
The syntax for clauses uses the \textcolor{purple}{\tt{cl}} operator, while disjunction is represented as the standard SMT-LIB \textcolor{purple}{\texttt{or}}.
We define the type $\kw{Clause}$ that encodes an Alethe clause as a list of propositions. The constructor $\veedot$ prepends an element to a list, and $\nil$ is the empty list.
Logically, clauses are interpreted as disjunctions via the function $\cal{F}$ defined by rewriting rules. For convenience, we also introduce the predicate $\pid$ asserting that a clause is provable.

\subsection{Classical connectives, quantifiers and facts}

Since SMT solvers are based on classical logic, we use the constructive connectives and quantifiers from the Lambdapi standard library and define the classical ones from them using the double-negation translation \cite{dowek:classical} as a definition.
%
\begin{align*}
& \mathop{\pic} p \coloneqq \mathop{\prf{}} (\neg \neg p) \\
& \mathop{=}:  \Pi {[a: \set]}, \el\, a \rightarrow \el\,a \rightarrow \prop \\
& p \lor^c q \coloneqq  \neg \neg p \lor \neg \neg q \\
& \forall^c \coloneqq \Pi {[a: \set]},  \Pi p: (\el\, a \ra \prop),  \forall \, x. \neg \neg  p\,x \\
&\texttt{classic}:\  \Pi [p: \prop], \pic (p \lor^c \neg p) \\
&\texttt{prop\_ext}:\  \Pi [p\,q: \prop], \pic (p \Leftrightarrow^c q ) \rightarrow \pic (p = q) \\
\end{align*}

Therefore, a step in an Alethe proof trace is represented as a proposition $\pic~p$, defined as the intuitionistic proof \prf{} of the doubly negated predicate.
Equality over small types is parameterized over types
$\el\,a$ for the type parameter $[a : \set{}]$ (the square brackets indicate that this parameter need not be given explicitly).
We also define classical connectives, quantifiers, and the choice operator $\epsilon$ (\cite[\S 2.1]{alethespec}) as illustrated above.
We prove the law of excluded middle and add the proposition of Boolean extensionality stating that classical equivalence coincides with equality over Booleans.
SMT logic enjoys the property of propositional completeness (also referred to as propositional degeneracy) asserting that $\forall^c A,~(A = \top) \lor^c (A = \bot)$. Moreover, propositionally equivalent formulas are equal. We thus obtain the theorems
\tt{classic} and \tt{prop\_ext}.
\begin{align*}
\end{align*}

\subsection{Encoding of Integers in Lambdapi}

The definition we use of integers in Lambdapi follows a common encoding found in many other theories, such as Rocq.
First, the type $\mathbb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or constructor \tt{I} (digit 1). 
The type $\mathbb{Z}$ is an inductive type representing integers in binary form.
An integer is either zero (with constructor \tt{Z0}) or a strictly positive number \tt{Zpos} (coded as a $\mathbb{P}$) or a strictly negative number \tt{Zneg} (whose opposite is stored as a $\mathbb{P}$ value).

\begin{align*}
&\mathbb{Z}: \type & &\mathbb{P}: \type \\
&|~\tt{Z0}: \mathbb{Z} & &|~\tt{H} : \mathbb{P} \\
&|~\tt{ZPos}: \mathbb{P} \ra \mathbb{Z} & &|~\tt{O}: \mathbb{P} \ra \mathbb{P} \\
&|~\tt{ZNeg}: \mathbb{P} \ra \mathbb{Z} & &|~\tt{I}: \mathbb{P} \ra \mathbb{P} \\
&\tt{int}: \set & &\tt{pos}: \set \\
&\el~\tt{int} \re \mathbb{Z} & &\el~\tt{pos} \re \mathbb{P} \\
\end{align*}

\subsection{Functions used in the translation}

We now provide an overview of how input problems expressed in a given SMT-LIB signature \cite[\S 5.2.1]{smtlib} are encoded. 
In order to avoid a notational clash with the Lambdapi signature $\Sigma$, we denote the set of SMT-LIB sorts as $\Theta^\mathcal{S}$, the set of function symbols $\Theta^\cal{F}$, and the set of variables $\Theta^\cal{X}$.
Alethe does not support the sorts \texttt{Array} and \texttt{String}. Moreover, we do not yet provide support for \texttt{Bitvector} and \texttt{Real}. Our translation is based on the following functions:

\begin{itemize}
\item $\cal{D}$ translates declarations of sorts and functions in $\Theta^\cal{S}$ and $\Theta^\mathcal{F}$ into constants,
\item $\cal{S}$ maps sorts to $\Sigma$ types,
\item $\cal{E}$ translates SMT expression to $\lpm$ terms,
\item $\cal{C}$ translates a list of commands  $c_1 \dots c_n$ of the form $i.~\Gamma \triangleright~\varphi~(\mathcal{R}~P)[A]$ to typing judgments $\Gamma \vdash_\Sigma i := M: N$.
\end{itemize}

\begin{definition}[Function $\mathcal{D}$ translating SMT sort and function symbol declarations]
For each sort symbol $s$ with arity $n$ in $\Theta^\cal{S}$ we create a constant $s: \set \ra \dots \ra \set$.
For each function symbol $f~\sigma^+$ in $\Theta^\cal{F}$ we create a constant $f: \cal{S}(\sigma^+)$.
\end{definition}

\smallskip

In other words, all SMT sorts used in the Alethe proof trace will be defined as constants that inhabit the type \set{} in the signature context $\Sigma$.
For every function declared in the SMT prelude, we define a constant whose arity follows the sort declared in the SMT prelude. The translation of sorts is formally defined as follows.

\smallskip

\begin{definition}[Function $\mathcal{S}$ translating sorts of expression] 
  The definition of $\mathcal{S}$(s) is as follows.
  \begin{itemize}
    \item Case $s = \textbf{Bool}$, then $\Sort{s} = \el\,o$,
    \item Case $s = \textbf{Int}$, then $\Sort{s} = \el~\texttt{int}$,
    \item Case $s = \sigma_1\,\sigma_2 \dots \sigma_n$ then $\Sort{s} = \el{} (\mathcal{S}(\sigma_1) \leadsto \dots \leadsto \mathcal{S}(\sigma_n))$,
    \item otherwise $\Sort{s} = \el\, \mathcal{D}(s)$.
    % where the symbol $s$ on the right-hand side denotes the Lambdapi sort introduced for the SMT sort $s$.
  \end{itemize}
\end{definition}


\begin{definition}[Function $\mathcal{E}$ translating SMT expressions]
The definition of $\E{e}$ is as follows.
\begin{itemize}
\setlength{\parskip}{0pt}
\item Case e $= (p~t_1~t_2\dots~t_n)$ and $p$ a logical operator, then $\E{e} = \E{t_1}~p^c~\dots~p^c~\E{t_n}$.
\item Case e $= (g~t_1\dots~t_n)$ with $g \in \Theta^\cal{F}$, then $\E{e} = (\mathcal{D}(g)~\E{t_1}~\dots~\E{t_n})$.
\item Case e $= (\approx~t_1~t_2)$ then $\E{e} = (\E{t_1} = \E{t_2})$.
\item Case e $= (Q~x_1 : \sigma_1  \dots x_n : \sigma_n ~t)$ where $Q\in \{\kw{forall}, \kw{exists}\}$, then $\E{e} = Q^c x_1: \cal{S}(\sigma_1), \dots, Q^c x_n: \cal{S}(\sigma_n), \E{t}$. 
% \item Case e $= (\kw{choice}~x : \sigma ~t)$ then $\E{e} = \epsilon~x: \cal{S}(\sigma),\, \E{t}$.
\item Case $e = (x: \sigma )$ with $x \in \Theta^\mathcal{X}$ a sorted variable, then $\E{e} = x: \cal{S}(\sigma)$.
% \item Case $e = (\kw{ite}~c~t~e)$, then $\E{e} = \kw{ite}~\E{c}~\E{t}~\E{e}$.
% \item Case $e = (\kw{xor}~a~b)$, then $\E{e} = \kw{xor}~\E{a}~\E{b}$.
% \item Case $e = (\kw{distinct}~t_1 \dots t_n)$, then $\E{e} = \kw{distinct}~(\E{t_1} \colon\colon ...\, \colon\colon ~\E{b} \colon\colon \square)$.
\end{itemize}
\end{definition}