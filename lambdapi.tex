\section{Reconstruction of \tt{la\_generic} step for LIA logic}
\label{sec:recon-lambdapi}

\subsection{Encoding of Integers in Lambdapi}


\begin{figure}
\centering
\begin{align*}\label{eq:eq1}
&\bb{P}: \type & &\bb{Z}: \type   & &\tt{Comp}: \type & &\bb{B}: \type \\
&|~\tt{H} : \bb{P} & &|~\tt{Z0}: \bb{Z} & &|~\tt{Eq}: \tt{Comp} & &|~\tt{true}: \bb{B} \\
&|~\tt{O}: \bb{P} \ra \bb{P} & &|~\tt{ZPos}: \bb{P} \ra \bb{Z} & &|~\tt{Lt}: \tt{Comp} & &|~\tt{false}: \bb{B} \\
&|~\tt{I}: \bb{P} \ra \bb{P} & &|~\tt{ZNeg}: \bb{P} \ra \bb{Z} & &|~\tt{Gt}: \tt{Comp} & &\\
&\tt{pos}: \set & &\tt{int}: \set & &\tt{comp}: \set & &\tt{bool}: \set \\
&\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \bb{Z} & &\el~\tt{comp} \re \tt{Comp} & &\el~\tt{bool} \re \bb{B}
\end{align*}
\caption{Overview of inductive types for integers and manipulating them}
\label{fig:sorts-constructors}
\end{figure}

The definition we use of integers in Lambdapi in \cref{fig:sorts-constructors} follows a common encoding found in many other theories, including the one adopted in the Rocq standard library \cite{Rocq-refman}.
First, the type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or constructor \tt{I} (digit 1). 
The type $\bb{Z}$ is an inductive type representing integers in binary form.
An integer is either zero (with constructor \tt{Z0}) or a strictly positive number \tt{Zpos} (coded as a $\bb{P}$) or a strictly negative number \tt{Zneg} (whose opposite is stored as a $\bb{P}$ value).
%
To enable quantification over integers, positive binary numbers, booleans, and comparison results, we introduce constants such as $\tt{int}: \set$ that represents codes for these types along with a rewrite rule that rewrite code to its corresponding type, for example $\el~\tt{int} \re \bb{Z}$.
The comparison inductive type $\tt{Comp}$ is used to specify comparison function. The infix function $\doteq$ define a decidable order comparison between two terms of type $\bb{Z}$. Similarly for $\bb{P}$ with the infix function $\tt{cmp}: \bb{P} \ra \bb{P} \ra \tt{Comp}$.

\begin{figure}
\centering
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \tt{Z0} + y \re y \\
& x + \tt{Z0} \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\tt{Zpos}~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \tt{Zpos}(\tt{add}~x~y)  \\
\end{align*}
\hfill
\end{minipage}
\begin{minipage}[t]{0.48\textwidth}
\begin{align*}
&\doteq : \bb{Z} \ra \bb{Z} \ra \tt{Comp} \\
& \tt{Z0} \doteq \tt{Z0} \re \tt{Eq} \\
& \tt{Z0} \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Z0} \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zpos}~\_ \doteq \tt{Z0} \re \tt{Gt} \\
& \tt{Zpos}~p \doteq \tt{Zpos}~q \re \tt{cmp}~p~q \\
& \tt{Zpos}~\_ \doteq \tt{Zneg}~\_ \re \tt{Gt} \\
& \tt{Zneg}~\_ \doteq \tt{Z0} \re \tt{Lt} \\
& \tt{Zneg}~\_ \doteq \tt{Zpos}~\_ \re \tt{Lt} \\
& \tt{Zneg}~p \doteq \tt{Zneg}~q \re \tt{cmp}~q~p \\
\end{align*}
\end{minipage}
\noindent
\[
\begin{array}{l@{\hspace{4em}}l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \bb{B} \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false} \\
\end{aligned}
&
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \bb{B} \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true} \\
\end{aligned}
\end{array}
\]
\noindent
\begin{align*}
&\leq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) & &\tt{istrue} : \bb{B} \ra \prop \\
&<: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) & &\tt{istrue}~\tt{true} \re \top \\
&\geq: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x < y) & &\tt{istrue}~\tt{false} \re \bot \\
&>: \bb{Z} \ra \bb{Z} \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y) & & \\
\end{align*}
\caption{Decidable equality, $+$ operator and inequalities relations definitions for $\bb{Z}$}
\label{fig:arith-ops}
\end{figure}

The arithmetic operator such as $+$ are constants defined by rewriting rules. In the following sections, we will refers to the rewriting rules for integers as $\ra_\bb{Z}$ and positive binary numbers as $\ra_\bb{P}$.
The confluence of the rewriting rules for the arithmetic of $\mathbb{Z}$ and $\mathbb{P}$ has been proven using CSI \cite{CSI}. A detailed proof of confluence can be found in \cref{app:confluence-int-pos}.
The inequality symbols for $\bb{Z}$ are binary predicates defined by rewriting rules over the decidable equality $\doteq$. They reduce to $\top$, $\bot$ (or negated) by $\equivL$ with rules of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
For example, $1 < 2 \hookrightarrow \tt{istrue}(\tt{isLt}(1 \doteq 2)) \hookrightarrow \tt{istrue}(\tt{isLt}(\tt{Lt})) \hookrightarrow \tt{istrue}(\tt{true}) \hookrightarrow \top$.

\subsection{Functions used in the translation}

We now outline the encoding of arithmetic expressions from SMT-LIB \cite[\S 5.2.1]{smtlib}. This extends the approach introduced in \cite{ColtellacciMD24} to handle arithmetic constructs.
To avoid notational conflicts with the Lambdapi signature $\Sigma$, we denote the set of SMT-LIB sorts as $\Theta^\mathcal{S}$, the set of function symbols $\Theta^\cal{F}$, and the set of variables $\Theta^\cal{X}$.
Our translation is based on the following functions:

\begin{itemize}
\item $\cal{D}$ translates declarations of sorts and functions in $\Theta^\cal{S}$ and $\Theta^\mathcal{F}$ into constants,
\item $\cal{S}$ maps sorts to $\Sigma$ types,
\item $\cal{E}$ translates SMT expression to $\lpm$ terms,
\item $\cal{C}$ translates a list of commands  $c_1 \dots c_n$ of the form $i.~\Gamma \triangleright~\varphi~(\mathcal{R}~P)[A]$ to typing judgments $\Gamma \vdash_\Sigma i := M: N$.
\end{itemize}

\begin{definition}[Function $\mathcal{D}$ translating SMT sort and function symbol declarations]
For each sort symbol $s$ with arity $n$ in $\Theta^\cal{S}$ we create a constant $s: \set^0 \ra \dots \ra^{n-1} \set$.
For each function symbol $f~\sigma^+$ in $\Theta^\cal{F}$ we create a constant $f: \cal{S}(\sigma^+)$.
\end{definition}

\begin{definition}[Function $\mathcal{S}$ translating sorts of expression] 
  The definition of $\mathcal{S}$(s) is as follows.
  \begin{itemize}
    \item Case $s = \textbf{Bool}$, then $\Sort{s} = \el\,o$,
    \item Case $s = \textbf{Int}$, then $\Sort{s} = \el~\texttt{int}$,
    \item Case $s = \sigma_1\,\sigma_2 \dots \sigma_n$ then $\Sort{s} = \el{} (\mathcal{S}(\sigma_1) \leadsto \dots \leadsto \mathcal{S}(\sigma_n))$,
    \item otherwise $\Sort{s} = \el\, \mathcal{D}(s)$.
  \end{itemize}
\end{definition}

\begin{definition}[Function $\mathcal{E}$ translating SMT expressions]
The definition of $\E{e}$ is as follows.
\begin{itemize}
\setlength{\parskip}{0pt}
\item Case e $= (+~t_1\dots~t_n)$, then $\E{e} = \E{t_1} + ~\dots~ +\E{t_n}$.
\item Case e $= (*~t_1\dots~t_n)$, then $\E{e} = \E{t_1} * ~\dots~ *\E{t_n}$.
\item Case e $= (-t)$, then $\E{e} = \mathop{\sim} \E{t_1}$.
\item Case e $= (-~t_1\dots~t_n)$, then $\E{e} = \E{t_1} - ~\dots~ - \E{t_n}$.
\item Case e $= (\approx~t_1~t_2)$ then $\E{e} = (\E{t_1} = \E{t_2})$.
\item Case $e = (x: \sigma )$ with $x \in \Theta^\mathcal{X}$ a sorted variable, then $\E{e} = x: \cal{S}(\sigma)$.
\end{itemize}
\end{definition}

We defined the function $\pid: \tt{Clause} \ra \type$, mapping each clause $c$ to the type $\pid~c$ of its proofs.
The type $\tt{Clause}: \type$ represent the type of clause encoded as list \cite[\S 3]{ColtellacciMD24}
with the constructor $\veedot: \prop \ra \tt{Clause} \ra \tt{Clause}$ and the empty clause $\nil: \tt{clause}$.
The function $\cal{C}$ encodes each step by invoking the functions $\cal{D},\cal{S}$ and $\cal{E}$, and provides a proof term corresponding to the Alethe rule applied at that step.

\begin{example}
The translation of the steps t2 and t5 in \cref{lst:smtexampleproof} with the input problem definitions give us:
\begin{lstlisting}[language=Lambdapi,mathescape=true]
symbol x: El int;
symbol y: El int;
...
opaque symbol t2: $\pid$ (¬ (3 < x)  ⟇ ¬ (x = 2) ⟇ ▩) ≔ begin ... end;
opaque symbol t5: $\pid$ (¬ (x + y < 1) ⟇ (¬ (x = 2))  ⟇ (¬ (0 = y)) ⟇ ▩) ≔ begin ... end;
...
\end{lstlisting}
\end{example}

The proof terms generated by $\mathcal{C}$ for steps \texttt{t2} and \texttt{t5} must faithfully represent the algorithm presented in \cref{sssect:la-in-alethe}.
While steps 1 through 7 of the algorithm correspond to explicit rewriting steps, the final step (step 8) — which involves summing all inequalities — represents a multi-step rewriting sequence.
This sequence reduced the initial sum to a decidable comparison between constants (e.g. $0 > 1 \re \bot$), which serves as the conclusion of the reduction.


The reflection technique introduced by \cite{reflection-origin-coq} leverages the reduction system of the proof assistant to produce an efficient decidable automatic
procedure for solving arithmetic goals over $\bb{Q}, \bb{R}$ and $\bb{Z}$. We decided to follow this approach to implement our decision procedure for evaluating inequality.
In the following section, we describe how we implemented this procedure for our case, and how we extended the definition of $\mathcal{C}$.