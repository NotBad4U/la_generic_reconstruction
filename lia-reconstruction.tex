\section{Reconstruction of linear arithmetic for LIA logic}
\label{sec:lia-reconstruction}

Proof by reflection is a technique used to write certified automation procedure by reducing the validity of a logical statement to a symbolic computation.
It relies on the following definitions: let $P: Z \ra \prop$ be a predicate over a data type Z and we have a function $f: Z \ra \tt{bool}$ such that the following theorem holds:

\begin{equation*}
\tt{f\_correct} : \forall z: Z, (f~z = \tt{true}) \ra (P~z)
\end{equation*}

If $\mathop{f} z$ reduces to \tt{true}, then the proof term  $\tt{f\_correct}~z~(\tt{relf}\,\tt{bool}\,\tt{true})$ with $\tt{refl}: \Pi A: \set, \Pi x: \el\,A, \pic (x = x)$, constitutes a proof of predicate $(P~z)$. In step 6 of the $\tt{la\_generic}$,
the primary challenge lies in reasoning modulo associativity and commutativity when manipulating expressions over $\bb{Z}$.
The key idea is to provide a normalization function that transforms a $\bb{Z}$ expression into a canonical form,
such that it can be reduce to a constant because variables will cancel each other, as is the case with the constant $f$ in \cref{ex:la_generic_example_red}.


\subsection{Representation}
\label{ssec:representation}

The procedure is based on an algebraic group structure, denoted as  $\bb{G}$ defined in \cref{fig:grp} which represents linear polynomials.
The base type for the elements of this group is specified as $\bb{G}: \type$. The unary operator $\tt{cst}$ denotes a constant from $\bb{Z}$.
A $\tt{var}$ constructor for "catch-all" case for subexpressions that we cannot model. These subexpressions will correspond to actual variables in $\bb{Z}$.
This constructor takes two arguments — both in $\bb{Z}$ — where the first denotes a constant coefficient and the second a variable identifier; further justification for this design will be provided later.
The constructor $\tt{mul}$  represents the multiplication of an element of $\bb{G}$ by a constant. The constructor $\tt{opp}$ corresponds to the inverse operator within the group.
Lastly, the constructor $\tt{add}$ represent the addition between two elements of \cref{fig:grp}.

To support associative and commutative operations, Lambdapi provides the modifiers \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]{associative commutative symbol},
ensuring that terms are systematically placed into a canonical form given a builtin ordering relation, as described in \cite{ACorigin} and \cite[\S 5]{univAC}.
Applying the \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]{associative commutative} modifiers to the infix constructor $\add{}{}$,
ensures that expressions involving sums of products are systematically canonicalized. Thus, equal variables are placed next to each other, facilitating simplification.

\begin{figure}
\begin{align*}
& \bb{G}: \type & & \reify{} : \bb{Z} \ra \bb{G} & & \den{}: \bb{G} \ra \bb{Z} \\
&|~\add{}{}: \bb{G} \ra \bb{G} \ra \bb{G} & & \reify{\tt{Z0}} \re \cst{\tt{Z0}} & & \den{\cst{c}} \re c \\
&|~\tt{var}: \bb{Z} \ra \bb{Z} \ra \bb{G} & & \mathop{\reify{\tt{ZPos}}} c \re \cst{c} & & \den{\opp{x}} \re  \sim (\den{x}) \\
&|~\tt{mul}: \bb{Z} \ra \bb{G} \ra \bb{G} & & \mathop{\reify{\tt{ZNeg}}} c \re \cst{c} & & \den{\mul{c}{x}} \re  c \times (\den{x}) \\
&|~\tt{opp}: \bb{G} \ra \bb{G} & & \reify{(x + y)} \re \add{(\reify{x})}{(\reify{y})} & & \den{\add{x}{y}} \re (\den{x}) + (\den{y}) \\
&|~\tt{cst}: \bb{Z} \ra \bb{G} & & \reify{(\sim x)} \re \opp{\reify{x}} & & \den{\var{c}{x}} \re  c \times x \\
&\tt{grp}: \set & & \mathop{\reify{(\mathop{\tt{Zpos}} c) * x}} \re \mul{c}{(\reify{x})}  & & \\
&\el~\tt{grp} \re \bb{G} & & \mathop{\reify{(\mathop{\tt{ZNeg}} c) * x}} \re \mul{c}{(\reify{x})} & & \\
& & & \mathop{\reify{x * (\mathop{\tt{Zpos}} c)}} \re \mul{c}{(\reify{x})}  & & \\
& & & \mathop{\reify{x * (\mathop{\tt{ZNeg}} c)}} \re \mul{c}{(\reify{x})} & & \\
& & & \mathop{\reify{x}} \re \var{1}{x} & &
\end{align*}
\caption{Definition of $\bb{G}$  Algebra and its reification ($\reify{}$) and denotation ($\den{}$) functions}
\label{fig:grp}
\end{figure}

\subsection{Associative Commutative Normalization}
\label{ssec:normalization}

\begin{figure}
\begin{align*}
&\add{\var{x}{c_1}}{\var{x}{c2}} \re \kw{var}~x~(c_1 + c_2) \\
&\add{\var{x}{c_1}}{(\add{\var{x}{c_2}}{y})} \re \add{\var{x}{(c_1 + c_2)}}{y} \\
&\add{\cst{c_1}}{\cst{c_2}} \re \cst{c_1 + c_2} \\
&\add{\cst{c_1}}{(\add{\cst{c_2}}{y})} \re \add{\cst{c_1 + c_2}}{y} \\
&\add{\cst{0}}{x} \re x \\
&\add{x}{\cst{0}} \re x \\
&\opp{\var{x}{c}} \re \var{x}{(-c)} \\
&\opp{\cst{c}} \re \cst{(-c)} \\
&\opp{\opp{x}} \re x \\
&\opp{\add{x}{y}} \re \add{(\opp{x})}{(\opp{y})} \\
&\mul{k}{\var{x}{c}} \re \var{x}{(k * c)} \\
&\mul{k}{\opp{x}} \re \mul{(-k)}{x} \\
&\mul{k}{(\add{x}{y})} \re \add{(\mul{k}{x})}{(\mul{k}{y})} \\
&\mul{k}{\cst{c}} \re \cst{(k * c)} \\
&\mul{c_1}{(\mul{c_2}{x})} \re \mul{(c_1 * c_2)}{x} \\
\end{align*}
\caption{Rewrite system on canonical forms}
\label{fig:grp-rw}
\end{figure}

For \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]{associative commutative} symbols, Lambdapi does not use matching modulo AC \cite{matching-mod-AC,kirchner_rsp} as this problem is NP-complete \cite{ac-modulo-np-complete}.
Instead, Lambdapi transforms sum expression of the form $\add{\var{c_1}{a_1}}{\add{\var{c_2}{a_2}}{\add{\dots}{\var{c_n}{a_n}}}}$ into a canonical form, ensuring that any pair of terms $\var{p}{x}$ and $\var{q}{x}$ involving the same variable $x$ are placed adjacent to each other.
This order is generalized by Lambdapi for any binary constructor \todo[ac]{Review this phrase}.
In this way, we will use the rewriting rules $\cref{fig:grp-rw}$ to reduce $\bb{G}$ expressions in canonical form. Notably, the resulting normal forms do not contain the constructors $\tt{mul}$ and $\tt{opp}$, as the associated rewrite rules eliminate them in favor of $\tt{var}, \tt{add}$ and $\tt{cst}$.

\begin{definition}[AC-canonical form]
Let $\leq$ be a total order on $\bb{G}$-terms defined as follows:
Constants are ordered such that $\tt{cst}(c_1) \leq \tt{cst}(c_2) < \var{p}{x}$ for any constants $c_1, c_2$ and any variable term $\var{p}{x}$, with $c_1 \leq c_2$.
For variable terms, $\var{p}{x} \leq \var{q}{y}$ if either $x < y$, or $x = y$ and $p \leq q$.
Let $\twoheadrightarrow^{AC}$ be the relation mapping every term t to its unique AC-canonical form denoted $[t]$.
\end{definition}

 Two terms are AC-equivalent iff their AC-canonical forms are equal.

\begin{definition}[Rewriting modulo AC-canonization]
Let $\ACcanon = \re_\Sigma\twoheadrightarrow^{AC}$, where $\Sigma$ contains the rewrite rules of \cref{fig:arith-ops,fig:grp-rw}. 
 \end{definition}

An $\ACcanon$ step is a standard $\re_\Sigma$ step with syntactic matching followed by ACcanonization. We now prove that the relation $\ACcanon$ terminates and is confluent.

\begin{lemma} The matching modulo AC relation $\rwModAC = \mathop{\simeq_{AC}}\re_\Sigma\mathop{\simeq_{AC}}$, which contains $\ACcanon$, terminates.
\begin{proof} \upshape{AProVE \cite{aprove}} automatically proves the termination of $\rwModAC$. \end{proof}
\end{lemma}

\begin{lemma} $\ACcanon$ is locally confluent on AC-canonical.
\begin{proof}
We show that every critical pair is joinable using $\ACcanon$ and confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
% In the following, the terms that are not between square brackets are in AC-canonical form. We also write $[\add{p}{q}]$ to denote either $\add{p}{q}$ or $\add{q}{p}$.
\end{proof}
\end{lemma}

To compare two $\bb{Z}$-terms, $t_1$ and $t_2$ wrt $\ACcanon$, the procedure involves reifying them into their corresponding $\bb{G}$-terms, denoted $[g_1]$ and $[g_2]$, using the reification function $\reify{(\_)}$,
and put in normal forms by $\twoheadrightarrow^{AC}$. Following the reduction rules specified in \cref{fig:grp-rw}, we can then compare their corresponding $\bb{Z}$-terms by applying the denotation function $\den{(\_)}$.
To validate this procedure, it is necessary to establish the correctness of the following diagram:

\begin{figure}
\center
% % https://q.uiver.app/#q=WzAsOCxbMSwyLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzMsMiwiXFxidWxsZXQiXSxbMywwLCJcXGJ1bGxldCJdLFswLDIsInRfMSA9X1xcbWF0aGJie1p9IHRfMiJdLFswLDAsIlxcRG93bmFycm93KFxcVXBhcnJvdyh0XzEpKSA9X1xcbWF0aGJie1p9IFxcRG93bmFycm93KFxcVXBhcnJvdyh0XzIpKSJdLFs0LDAsIlxcRG93bmFycm93KFtnXzFdKSA9X1xcbWF0aGJie1p9IFxcRG93bmFycm93KFtnXzJdKSJdLFs0LDIsImdfMSA9X1xcbWF0aGJie1p9IGdfMiJdLFswLDEsIlxcRG93bmFycm93KFxcVXBhcnJvdyhcXF8pKSJdLFswLDIsIlxcaWZmIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZG90dGVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJbXFxfXSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFszLDIsIlxcRG93bmFycm93KFxcXykiXSxbMSwyLCIiLDAseyJzdHlsZSI6eyJuYW1lIjoiY29ybmVyIn19XV0=
\[\begin{tikzcd}[ampersand replacement=\&]
	{\Downarrow(\Uparrow(t_1)) =_\mathbb{Z} \Downarrow(\Uparrow(t_2))} \& \bb{G} \&\& \bb{G} \& {\Downarrow([g_1]) =_\mathbb{Z} \Downarrow([g_2])} \\
	\\
	{t_1 =_\mathbb{Z} t_2} \& \bb{Z} \&\& \bb{Z} \& {\den{g_1} =_\mathbb{Z} \den{g_2}}
	\arrow["{[\_]}", dashed, from=1-2, to=1-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-2, to=3-4]
	\arrow["{\Downarrow(\_)}", from=1-4, to=3-4]
	\arrow["{\Downarrow(\Uparrow(\_))}", from=3-2, to=1-2]
	\arrow["\iff"{description}, dotted, no head, from=3-2, to=3-4]
\end{tikzcd}\]
\end{figure}

by the correctness theorem:

\begin{theorem}[Normalization correctness]
For all $\bb{G}$-terms $t$, we have $(\den{[t]}) = (\den{t})$ where $[t]$ is the AC-canonical form of $t$ with respect to $\longrightarrow^{AC}_\Sigma$.
\end{theorem}

We make use of \cref{lem:conv} to embed $\bb{Z}$-terms into $\bb{G}$ in order to normalize and subsequent comparison.

\begin{lemma}[Conversion]
For all $x: \bb{Z}$, we have $x = (\mathop{\den{(\reify{x})}})$.
\label{lem:conv}
\end{lemma}

\begin{example}[Lambdapi proof term for step \tt{t5}]
\begin{lstlisting}[language=Lambdapi,mathescape=true]
symbol x: El int;
symbol y: El int;

opaque symbol t5: $\pid$ (¬ (x + y < 1) ⟇ (¬ (x = 2))  ⟇ (¬ (0 = y)) ⟇ ▩) ≔ begin

end;
\end{lstlisting}
\end{example}