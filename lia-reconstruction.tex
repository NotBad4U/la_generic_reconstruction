\section{Reconstruction of linear arithmetic for LIA logic}
\label{sec:lia-reconstruction}

Proof by reflection is a technique used to write certified automation procedure by reducing the validity of a logical statement to a symbolic computation.
It relies on the following definitions: let $P: Z \ra \prop$ be a predicate over a data type Z and we have a function $f: Z \ra \tt{bool}$ such that the following theorem holds:

\begin{equation*}
\tt{f\_correct} : \forall z: Z, (f~z = \tt{true}) \ra (P~z)
\end{equation*}

If $\mathop{f} z$ reduces to \tt{true}, then the proof term  $\tt{f\_correct}~z~(\tt{relf}\,\tt{bool}\,\tt{true})$ with $\tt{refl}: \Pi A: \set, \Pi x: \el\,A, \pic (x = x)$, constitutes a proof of predicate $(P~z)$. In step 6 of the $\tt{la\_generic}$,
the primary challenge lies in reasoning modulo associativity and commutativity when manipulating expressions over $\bb{Z}$.
The key idea is to provide a normalization function that transforms a $\bb{Z}$ expression into a canonical form,
such that it can be reduce to a constant because variables will cancel each other, as is the case with $f$ in \cref{ex:la_generic_example_red}.


\subsection{Representation}
\label{ssec:representation}

The procedure is based on a group structure, denoted as  $\bb{G}$ defined in \cref{fig:grp} which represents linear polynomials.
The base type for the elements of this group is specified as $\bb{G}: \type$. The unary operator $\tt{cst}$ denotes a constant from $\bb{Z}$.
A $\tt{var}$ constructor for "catch-all" case for subexpressions that we cannot model. These subexpressions will correspond to actual variables in $\bb{Z}$.
The constructor $\tt{mul}$  represents the multiplication of an element of $\bb{G}$ by a constant. The constructor $\tt{opp}$ corresponds to the inverse operator within the group.
Lastly, the constructor $\tt{add}$ represent the addition between two elements of \cref{fig:grp}.

To support associative and commutative operations, Lambdapi provides the modifiers \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]{associative commutative symbol},
ensuring that terms are systematically placed into a canonical form given a builtin ordering relation, as described in \cite{ACorigin} and \cite[\S 5]{univAC}.
Applying the \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]{associative commutative} modifiers to the constructor $\tt{add}$,
ensures that expressions involving sums of products are systematically canonicalized. Thus, equal variables are placed next to each other, facilitating simplification.

\begin{figure}
\begin{align*}
& \bb{G}: \type & & \reify{} : \bb{Z} \ra \bb{G} & & \den{}: \bb{G} \ra \bb{Z} \\
&|~\tt{add}: \bb{G} \ra \bb{G} \ra \bb{G} & & \reify{\tt{Z0}} \re \cst{\tt{Z0}} & & \den{\cst{c}} \re c \\
&|~\tt{var}: \bb{Z} \ra \bb{Z} \ra \bb{G} & & \mathop{\reify{\tt{ZPos}}} c \re \cst{c} & & \den{\opp{x}} \re  \sim (\den{x}) \\
&|~\tt{mul}: \bb{Z} \ra \bb{G} \ra \bb{G} & & \mathop{\reify{\tt{ZNeg}}} c \re \cst{c} & & \den{\mul{c}{x}} \re  c \times (\den{x}) \\
&|~\tt{opp}: \bb{G} \ra \bb{G} & & \reify{(x + y)} \re \add{(\reify{x}})({\reify{y})} & & \den{\add{x}{y}} \re (\den{x}) + (\den{y}) \\
&|~\tt{cst}: \bb{Z} \ra \bb{G} & & \reify{(\sim x)} \re \opp{\reify{x}} & & \den{\var{c}{x}} \re  c \times x \\
&\tt{grp}: \set & & \mathop{\reify{(\mathop{\tt{Zpos}} c) * x}} \re \mul{c}{(\reify{x})}  & & \\
&\el~\tt{grp} \re \bb{G} & & \mathop{\reify{(\mathop{\tt{ZNeg}} c) * x}} \re \mul{c}{(\reify{x})} & & \\
& & & \mathop{\reify{x * (\mathop{\tt{Zpos}} c)}} \re \mul{c}{(\reify{x})}  & & \\
& & & \mathop{\reify{x * (\mathop{\tt{ZNeg}} c)}} \re \mul{c}{(\reify{x})} & & \\
& & & \mathop{\reify{x}} \re \var{1}{x} & &
\end{align*}
\caption{Definition of $\bb{G}$  Algebra and its reification ($\reify{}$) and denotation ($\den{}$) functions}
\label{fig:grp}
\end{figure}

\subsection{Normalization}
\label{ssec:normalization}


$\reify{(x + y + (- x) + (- y))} \re 
\var{1}{x} + \var{1}{y} + \tt{opp}(\var{1}{x}) + \tt{opp}(\var{1}{y}) \re 
\var{1}{x} + \var{1}{y} + \var{-1}{x} + \var{-1}{y} 
\simeq_{AC} \var{1}{x} + \var{-1}{x} + \var{1}{y} + \var{-1}{y}
\re \cst{0}$

\begin{definition}[AC-canonical form]
Let $\leq$ be any total order on $\bb{G}$-terms with $\tt{cst}(c) < \var{p}{x}$ for all $c$, and $\var{p}{x} \leq \var{q}{y}$ iff $x < y$ or else $x = y$ and $p \leq q$.
\end{definition}

% The AC-canonization of a term $t$ of $\cal{C}$ is defined as $[t]_{AC} = \mathit{comb}_{\sqcup} [\texttt{sort}(\mathit{aliens}_{\sqcup}(t))]$, where $\texttt{sort(l)}$ is the list of the elements of $l$ in increasing order with respect to $\leq$. The relation associating every term $t$ with its AC-canonization $[t]_{AC}$ is denoted $\RRAC$. Two terms $t$ and $t'$ are AC-equivalent if $[t]_{AC} = [t']_{AC}$.
% The term $t$ is in AC-canonical form if $t = [t]_{AC}$ and if every strict subterm of $t$ is in AC-canonical form. 

\begin{figure}
\begin{align*}
&\add{\var{x}{c_1}}{\var{x}{c2}} \re \kw{var}~x~(c_1 + c_2) \\
&\add{\var{x}{c_1}}{(\add{\var{x}{c_2}}{y})} \re \add{\var{x}{(c_1 + c_2)}}{y} \\
&\add{\cst{c_1}}{\cst{c_2}} \re \cst{c_1 + c_2} \\
&\add{\cst{c_1}}{(\add{\cst{c_2}}{y})} \re \add{\cst{c_1 + c_2}}{y} \\
&\add{\cst{0}}{x} \re x \\
&\add{x}{\cst{0}} \re x \\
&\opp{\var{x}{c}} \re \var{x}{(-c)} \\
&\opp{\cst{c}} \re \cst{(-c)} \\
&\opp{\opp{x}} \re x \\
&\opp{\add{x}{y}} \re \add{(\opp{x})}{(\opp{y})} \\
&\mul{k}{\var{x}{c}} \re \var{x}{(k * c)} \\
&\mul{k}{\opp{x}} \re \mul{(-k)}{x} \\
&\mul{k}{(\add{x}{y})} \re \add{(\mul{k}{x})}{(\mul{k}{y})} \\
&\mul{k}{\cst{c}} \re \cst{(k * c)} \\
&\mul{c_1}{(\mul{c_2}{x})} \re \mul{(c_1 * c_2)}{x} \\
\end{align*}
\caption{Rewrite system on canonical forms}
\label{fig:grp-rw}
\end{figure}
\todo[ac]{mettre les coeffs a gauche}


% https://q.uiver.app/#q=WzAsOCxbMSwyLCJcXG1hdGhiYntafSJdLFsxLDAsIlxcbWF0aGNhbHtSfSJdLFszLDAsIlxcbWF0aGNhbHtSfSJdLFszLDIsIlxcbWF0aGJie1p9Il0sWzAsMiwidF8xID1fXFxtYXRoYmJ7Wn0gdF8yIl0sWzQsMiwiZGVub3RlKHRfMSkgPV9cXG1hdGhiYntafSBkZW5vdGUodF8yKSJdLFswLDAsInJlaWZ5KHRfMSkgPV9cXG1hdGhjYWx7Un0gcmVpZnkodF8yKSJdLFs0LDAsIm5vcm0odF8xKSA9X1xcbWF0aGNhbHtSfSBub3JtKHRfMikiXSxbMCwxLCJyZWlmeSJdLFsxLDIsIlxccmlnaHRhcnJvd197QUN9IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZG90dGVkIn19fV0sWzIsMywiZGVub3RlIl0sWzAsMywiXFxlcXVpdiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRvdHRlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
\begin{tikzcd}[ampersand replacement=\&,column sep=small]
	{\reify{(t_1)} =_\bb{Z} \reify{(t_2)}} \& {\bb{G}} \&\& {\bb{G}} \& {{t_1\downarrow_{AC}} =_\bb{Z} t_2\downarrow_{AC}} \\
	\\
	{t_1 =_\mathbb{Z} t_2} \& {\mathbb{Z}} \&\& {\mathbb{Z}} \& {\den{({t_1\downarrow_{AC}})} =_\mathbb{Z} \den{({t_2\downarrow_{AC}})}}
	\arrow["{\rightarrow_{AC}}", dotted, from=1-2, to=1-4]
	\arrow["denote", from=1-4, to=3-4]
	\arrow["reify", from=3-2, to=1-2]
	\arrow["\iff"{description}, dotted, no head, from=3-2, to=3-4]
\end{tikzcd}

% \begin{definition}
%     Let $\mathit{aliens}_{\sqcup}: \mathcal{C} \rightarrow \mathcal{C}^+$ be the function mapping every term in $\mathcal{C}$ to a non-empty list of terms such that $\mathit{aliens}_{\sqcup}(t) = \mathit{aliens}_{\sqcup}(u) \circ \mathit{aliens}_{\sqcup}(v)$ if $t = u \sqcup v$, and $\mathit{aliens}_{\sqcup}(t) = [t]$ otherwise.
  
%     Conversely, let $\mathit{comb}_{\sqcup} \colon \mathcal{C}^+ \rightarrow \mathcal{C}$ be the function mapping a non-empty list of $\mathcal{C}$-terms to a term such that  $\mathit{comb}_{\sqcup}[t] = t$ and for all $n \geq 2,  \mathit{comb}_{\sqcup}[t_1, \dots, t_n] = t_1 \sqcup \mathit{comb}_{\sqcup}[t_2,\dots,t_n]$.
%   \end{definition}
  
%   \smallskip 
  
% For example $\mathit{aliens}_{\sqcup}((x \sqcup y) \sqcup z) = [x, y, z]$ and $\mathit{comb}_{\sqcup}[x, y, z] = ((x \sqcup y) \sqcup z)$.

% \begin{example}
% Assuming that the terms $x$ and $y$ are ordered $x < y$, the AC-canonical form of $XXX$ is $XXX$.
% \end{example}
  
\smallskip
  
\begin{definition}[Rewriting modulo AC-canonization]
Let $\RAC = \RRAC \R$, where $\mathcal{R}$ is defined by the rewrite rules of ??.
\label{def:RAC}
\end{definition}
  
\smallskip
  
An $\RAC$ step is an AC-canonization followed by a standard $\lra_{\mathcal{R}}$ step with syntactic matching.
  
\subsection{Generation of the proof term for \tt{la\_generic} in \tt{LIA}}
\label{ssec:gen-lia-proof}